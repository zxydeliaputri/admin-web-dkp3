{"version":3,"sources":["../../src/middleware/index.ts","../../src/middleware/withMiddlewareAuth.ts"],"sourcesContent":["export { withMiddlewareAuth } from './withMiddlewareAuth';\n","import { NextResponse } from 'next/server';\nimport { NextMiddleware } from 'next/server';\nimport {\n  CookieOptions,\n  setCookies,\n  COOKIE_OPTIONS,\n  TOKEN_REFRESH_MARGIN,\n  NextRequestMiddlewareAdapter,\n  NextResponseMiddlewareAdapter,\n  jwtDecoder,\n  User\n} from '@supabase/auth-helpers-shared';\n\nclass NoPermissionError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name() {\n    return this.constructor.name;\n  }\n}\n\nexport interface withMiddlewareAuthOptions {\n  /**\n   * Path relative to the site root to redirect an\n   * unauthenticated visitor.\n   *\n   * The original request route will be appended via\n   * a `redirectedFrom` query parameter, ex: `?redirectedFrom=%2Fdashboard`\n   */\n  redirectTo?: string;\n  cookieOptions?: CookieOptions;\n  tokenRefreshMargin?: number;\n  authGuard?: {\n    isPermitted: (user: User) => Promise<boolean>;\n    redirectTo: string;\n  };\n}\nexport type withMiddlewareAuth = (\n  options?: withMiddlewareAuthOptions\n) => NextMiddleware;\n\nexport const withMiddlewareAuth: withMiddlewareAuth =\n  (options: withMiddlewareAuthOptions = {}) =>\n  async (req) => {\n    try {\n      if (\n        !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n        !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n      ) {\n        throw new Error(\n          'NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!'\n        );\n      }\n      if (!req.cookies) {\n        throw new Error('Not able to parse cookies!');\n      }\n      const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n      const tokenRefreshMargin =\n        options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n      const access_token = req.cookies.get(\n        `${cookieOptions.name!}-access-token`\n      );\n      const refresh_token = req.cookies.get(\n        `${cookieOptions.name!}-refresh-token`\n      );\n\n      const res = NextResponse.next();\n\n      const getUser = async (): Promise<{\n        user: any;\n        error: any;\n      }> => {\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n        // Get payload from access token.\n        const jwtUser = jwtDecoder(access_token);\n        if (!jwtUser?.exp) {\n          throw new Error('Not able to parse JWT payload!');\n        }\n        const timeNow = Math.round(Date.now() / 1000);\n        if (jwtUser.exp < timeNow + tokenRefreshMargin) {\n          if (!refresh_token) {\n            throw new Error('No refresh_token cookie found!');\n          }\n          const requestHeaders: HeadersInit = new Headers();\n          requestHeaders.set('accept', 'json');\n          requestHeaders.set(\n            'apiKey',\n            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n          );\n          requestHeaders.set(\n            'authorization',\n            `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`\n          );\n\n          const data = await fetch(\n            `${process.env.NEXT_PUBLIC_SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`,\n            {\n              method: 'POST',\n              headers: requestHeaders,\n              body: JSON.stringify({ refresh_token })\n            }\n          )\n            .then((res) => res.json())\n            .catch((e) => ({\n              error: String(e)\n            }));\n          setCookies(\n            new NextRequestMiddlewareAdapter(req),\n            new NextResponseMiddlewareAdapter(res),\n            [\n              { key: 'access-token', value: data!.access_token },\n              { key: 'refresh-token', value: data!.refresh_token! }\n            ].map((token) => ({\n              name: `${cookieOptions.name}-${token.key}`,\n              value: token.value,\n              domain: cookieOptions.domain,\n              maxAge: cookieOptions.lifetime ?? 0,\n              path: cookieOptions.path,\n              sameSite: cookieOptions.sameSite\n            }))\n          );\n          return { user: data?.user ?? null, error: data?.error };\n        }\n        return { user: jwtUser, error: null };\n      };\n\n      const authResult = await getUser();\n\n      if (authResult.error) {\n        throw new Error(\n          `Authorization error, redirecting to login page: ${authResult.error.message}`\n        );\n      } else if (!authResult.user) {\n        throw new Error('No auth user, redirecting');\n      } else if (\n        options.authGuard &&\n        !(await options.authGuard.isPermitted(authResult.user))\n      ) {\n        throw new NoPermissionError('User is not permitted, redirecting');\n      }\n\n      // Authentication successful, forward request to protected route\n      return res;\n    } catch (err: unknown) {\n      let { redirectTo = '/' } = options;\n      if (\n        err instanceof NoPermissionError &&\n        !!options?.authGuard?.redirectTo\n      ) {\n        redirectTo = options.authGuard.redirectTo;\n      }\n      if (err instanceof Error) {\n        console.log(\n          `Could not authenticate request, redirecting to ${redirectTo}:`,\n          err\n        );\n      }\n      const redirectUrl = req.nextUrl.clone();\n      redirectUrl.pathname = redirectTo;\n      redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname);\n      // Authentication failed, redirect request\n      return NextResponse.redirect(redirectUrl);\n    }\n  };\n"],"mappings":"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","names":[]}