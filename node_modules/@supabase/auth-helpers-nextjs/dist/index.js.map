{"version":3,"sources":["../src/index.ts","../src/handlers/auth.ts","../src/handlers/callback.ts","../src/utils/getUser.ts","../src/utils/log.ts","../src/constants.ts","../src/handlers/user.ts","../src/handlers/logout.ts","../src/utils/initSupabase.ts","../src/middleware/withMiddlewareAuth.ts","../src/utils/getProviderToken.ts","../src/utils/withPageAuth.ts","../src/utils/withApiAuth.ts","../src/utils/getAccessToken.ts","../src/utils/supabaseServerClient.ts"],"sourcesContent":["// Types\nexport type { User } from '@supabase/supabase-js';\n\n// Methods\nexport * from './handlers';\nexport * from './middleware';\nexport { default as getUser } from './utils/getUser';\nexport { getProviderToken } from './utils/getProviderToken';\nexport { default as withPageAuth } from './utils/withPageAuth';\nexport { default as withApiAuth } from './utils/withApiAuth';\nexport { default as supabaseServerClient } from './utils/supabaseServerClient';\nexport { supabaseClient, SupabaseClient } from './utils/initSupabase';\nexport { default as logger } from './utils/log';\n","import { CookieOptions, COOKIE_OPTIONS, TOKEN_REFRESH_MARGIN } from '@supabase/auth-helpers-shared';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport handleCallback from './callback';\nimport handleUser from './user';\nimport handleLogout from './logout';\n\nexport interface HandleAuthOptions {\n  cookieOptions?: CookieOptions;\n  logout?: { returnTo?: string };\n  tokenRefreshMargin?: number;\n}\n\nexport default function handleAuth(options: HandleAuthOptions = {}) {\n  return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {\n    const { logout } = options;\n    const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n    const tokenRefreshMargin =\n      options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n    let {\n      query: { supabase: route }\n    } = req;\n\n    route = Array.isArray(route) ? route[0] : route;\n\n    switch (route) {\n      case 'callback':\n        return handleCallback(req, res, { cookieOptions });\n      case 'user':\n        return await handleUser(req, res, {\n          cookieOptions,\n          tokenRefreshMargin\n        });\n      case 'logout':\n        return handleLogout(req, res, {\n          cookieOptions,\n          ...logout\n        });\n      default:\n        res.status(404).end();\n    }\n  };\n}\n","import { \n  CookieOptions, \n  setCookies, \n  COOKIE_OPTIONS, \n  NextRequestAdapter, \n  NextResponseAdapter \n} from '@supabase/auth-helpers-shared';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport getUser from '../utils/getUser';\n\nexport interface HandleCallbackOptions {\n  cookieOptions?: CookieOptions;\n}\n\ntype AuthCookies = Parameters<typeof setCookies>[2];\n\nexport default async function handleCallback(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  options: HandleCallbackOptions = {}\n) {\n  if (req.method !== 'POST') {\n    res.setHeader('Allow', 'POST');\n    res.status(405).end('Method Not Allowed');\n  }\n  const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n  const { event, session } = req.body;\n\n  if (!event) throw new Error('Auth event missing!');\n  if (event === 'USER_UPDATED') {\n    await getUser({ req, res }, { forceRefresh: true });\n  }\n  if (event === 'SIGNED_IN') {\n    if (!session) throw new Error('Auth session missing!');\n    setCookies(\n      new NextRequestAdapter(req),\n      new NextResponseAdapter(res),\n      [\n        session.access_token\n          ? { key: 'access-token', value: session.access_token }\n          : null,\n        session.refresh_token\n          ? { key: 'refresh-token', value: session.refresh_token }\n          : null,\n        session.provider_token\n          ? { key: 'provider-token', value: session.provider_token }\n          : null\n      ].reduce<AuthCookies>((acc, token) => {\n        if (token) {\n          acc.push({\n            name: `${cookieOptions.name}-${token.key}`,\n            value: token.value,\n            domain: cookieOptions.domain,\n            maxAge: cookieOptions.lifetime ?? 0,\n            path: cookieOptions.path,\n            sameSite: cookieOptions.sameSite\n          });\n        }\n        return acc;\n      }, [])\n    );\n  }\n  if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n    setCookies(\n      new NextRequestAdapter(req),\n      new NextResponseAdapter(res),\n      ['access-token', 'refresh-token', 'provider-token'].map((key) => ({\n        name: `${cookieOptions.name}-${key}`,\n        value: '',\n        maxAge: -1\n      }))\n    );\n  }\n  res.status(200).json({});\n}\n","import {\n  GetServerSidePropsContext,\n  NextApiRequest,\n  NextApiResponse\n} from 'next';\nimport { User, createClient } from '@supabase/supabase-js';\nimport {\n  ApiError,\n  CookieOptions,\n  setCookies,\n  COOKIE_OPTIONS,\n  TOKEN_REFRESH_MARGIN,\n  NextRequestAdapter,\n  NextResponseAdapter,\n  jwtDecoder,\n  JWTPayloadFailed,\n  AccessTokenNotFound,\n  RefreshTokenNotFound,\n  AuthHelperError,\n  CookieNotFound,\n  ErrorPayload\n} from '@supabase/auth-helpers-shared';\nimport logger from '../utils/log';\nimport { PKG_NAME, PKG_VERSION } from '../constants';\n\ninterface ResponsePayload {\n  user: User | null;\n  accessToken: string | null;\n  error?: ErrorPayload;\n}\n\nexport interface GetUserOptions {\n  cookieOptions?: CookieOptions;\n  forceRefresh?: boolean;\n  tokenRefreshMargin?: number;\n}\n\nexport default async function getUser(\n  context:\n    | GetServerSidePropsContext\n    | { req: NextApiRequest; res: NextApiResponse },\n  options: GetUserOptions = { forceRefresh: false }\n): Promise<ResponsePayload> {\n  try {\n    if (\n      !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n      !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n    ) {\n      throw new Error(\n        'NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!'\n      );\n    }\n    if (!context.req.cookies) {\n      throw new CookieNotFound();\n    }\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL,\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,\n      {\n        headers: {\n          'X-Client-Info': `${PKG_NAME}@${PKG_VERSION}`\n        }\n      }\n    );\n    const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n    const tokenRefreshMargin =\n      options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n    const access_token =\n      context.req.cookies[`${cookieOptions.name}-access-token`];\n    const refresh_token =\n      context.req.cookies[`${cookieOptions.name}-refresh-token`];\n\n    if (!access_token) {\n      throw new AccessTokenNotFound();\n    }\n    // Get payload from access token.\n    const jwtUser = jwtDecoder(access_token);\n    if (!jwtUser?.exp) {\n      throw new JWTPayloadFailed();\n    }\n    const timeNow = Math.round(Date.now() / 1000);\n    if (options.forceRefresh || jwtUser.exp < timeNow + tokenRefreshMargin) {\n      // JWT is expired, let's refresh from Gotrue\n      if (!refresh_token) throw new RefreshTokenNotFound();\n      logger.info('Refreshing access token...');\n      const { data, error } = await supabase.auth.api.refreshAccessToken(\n        refresh_token\n      );\n      if (error) {\n        throw error;\n      } else {\n        logger.info('Saving tokens to cookies...');\n        setCookies(\n          new NextRequestAdapter(context.req),\n          new NextResponseAdapter(context.res),\n          [\n            { key: 'access-token', value: data!.access_token },\n            { key: 'refresh-token', value: data!.refresh_token! }\n          ].map((token) => ({\n            name: `${cookieOptions.name}-${token.key}`,\n            value: token.value,\n            domain: cookieOptions.domain,\n            maxAge: cookieOptions.lifetime ?? 0,\n            path: cookieOptions.path,\n            sameSite: cookieOptions.sameSite\n          }))\n        );\n        return { user: data!.user!, accessToken: data!.access_token };\n      }\n    } else {\n      logger.info('Getting the user object from the database...');\n      const { user, error: getUserError } = await supabase.auth.api.getUser(\n        access_token\n      );\n      if (getUserError) {\n        throw getUserError;\n      }\n      return { user: user!, accessToken: access_token };\n    }\n  } catch (e) {\n    let response: ResponsePayload = { user: null, accessToken: null };\n    if (e instanceof JWTPayloadFailed) {\n      logger.info('JWTPayloadFailed error has happened!');\n      response.error = e.toObj();\n    } else if (e instanceof AuthHelperError) {\n      // do nothing, these are all just to disrupt the control flow\n    } else {\n      const error = e as ApiError;\n      logger.error(error.message);\n    }\n    return response;\n  }\n}\n","const dev = process.env.NODE_ENV !== 'production';\n\nconst logger = {\n  log: (message?: any, ...optionalParams: any[]) => {\n    dev ? console.log(message, ...optionalParams) : null;\n  },\n  error: (message?: any, ...optionalParams: any[]) => {\n    console.error(message, ...optionalParams);\n  },\n  info: (message?: any, ...optionalParams: any[]) => {\n    logger.log(message, ...optionalParams);\n  },\n  debug: (message?: any, ...optionalParams: any[]) => {\n    logger.log(message, ...optionalParams);\n  },\n  warn: (message?: any, ...optionalParams: any[]) => {\n    dev ? logger.error(message, ...optionalParams) : null;\n  }\n};\n\nexport default logger;\n","export const PKG_NAME = \"@supabase/auth-helpers-nextjs\";\nexport const PKG_VERSION = \"0.2.8\";\n","import {\n  ApiError,\n  CookieOptions,\n  COOKIE_OPTIONS,\n  jwtDecoder,\n  TOKEN_REFRESH_MARGIN,\n  JWTPayloadFailed,\n  AuthHelperError,\n  ErrorPayload,\n  AccessTokenNotFound,\n  CookieNotFound\n} from '@supabase/auth-helpers-shared';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport getUser from '../utils/getUser';\nimport logger from '../utils/log';\n\ninterface ResponsePayload {\n  user: null;\n  accessToken: null;\n  error?: ErrorPayload;\n}\n\nexport interface HandleUserOptions {\n  cookieOptions?: CookieOptions;\n  tokenRefreshMargin?: number;\n}\n\nexport default async function handleUser(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  options: HandleUserOptions = {}\n) {\n  try {\n    if (!req.cookies) {\n      throw new CookieNotFound();\n    }\n    const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n    const tokenRefreshMargin =\n      options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n    const access_token = req.cookies[`${cookieOptions.name}-access-token`];\n\n    if (!access_token) {\n      throw new AccessTokenNotFound();\n    }\n\n    // Get payload from cached access token.\n    const jwtUser = jwtDecoder(access_token);\n    if (!jwtUser?.exp) {\n      throw new JWTPayloadFailed();\n    }\n    const timeNow = Math.round(Date.now() / 1000);\n    if (jwtUser.exp < timeNow + tokenRefreshMargin) {\n      // JWT is expired, let's refresh from Gotrue\n      const response = await getUser(\n        { req, res },\n        { cookieOptions, tokenRefreshMargin }\n      );\n      res.status(200).json(response);\n    } else {\n      // Transform JWT and add note that it ise cached from JWT.\n      const user = {\n        id: jwtUser.sub,\n        aud: null,\n        role: null,\n        email: null,\n        email_confirmed_at: null,\n        phone: null,\n        confirmed_at: null,\n        last_sign_in_at: null,\n        app_metadata: {},\n        user_metadata: {},\n        identities: [],\n        created_at: null,\n        updated_at: null,\n        'supabase-auth-helpers-note':\n          'This user payload is retrieved from the cached JWT and might be stale. If you need up to date user data, please call the `getUser` method in a server-side context!'\n      };\n      const mergedUser = { ...user, ...jwtUser };\n      res.status(200).json({ user: mergedUser, accessToken: access_token });\n    }\n  } catch (e) {\n    let response: ResponsePayload = { user: null, accessToken: null };\n    if (e instanceof JWTPayloadFailed) {\n      logger.info('JWTPayloadFailed error has happened!');\n      response.error = e.toObj();\n    } else if (e instanceof AuthHelperError) {\n      // do nothing because since this just means the user isn't logged in\n    } else {\n      const error = e as ApiError;\n      logger.error(error.message);\n    }\n    res.status(200).json(response);\n  }\n}\n","import { \n  CookieOptions, \n  setCookies, \n  COOKIE_OPTIONS, \n  NextRequestAdapter, \n  NextResponseAdapter \n} from '@supabase/auth-helpers-shared';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { supabaseClient } from '../utils/initSupabase';\n\nexport interface HandleLogoutOptions {\n  cookieOptions?: CookieOptions;\n  returnTo?: string;\n}\n\nexport default function handleLogout(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  options: HandleLogoutOptions = {}\n) {\n  let { returnTo } = req.query;\n  if (!returnTo) returnTo = options?.returnTo ?? '/';\n  returnTo = Array.isArray(returnTo) ? returnTo[0] : returnTo;\n  returnTo = returnTo.charAt(0) === '/' ? returnTo : `/${returnTo}`;\n  const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n\n  // Logout request to Gotrue\n  const access_token = req.cookies[`${cookieOptions.name}-access-token`];\n  if (access_token) supabaseClient.auth.api.signOut(access_token);\n\n  // Delete cookies\n  setCookies(\n    new NextRequestAdapter(req),\n    new NextResponseAdapter(res),\n    ['access-token', 'refresh-token', 'provider-token'].map((key) => ({\n      name: `${cookieOptions.name}-${key}`,\n      value: '',\n      maxAge: -1\n    }))\n  );\n\n  res.redirect(returnTo as string);\n}\n","import { createClient } from '@supabase/supabase-js';\nexport { SupabaseClient } from '@supabase/supabase-js';\nimport { PKG_NAME, PKG_VERSION } from '../constants';\n\nconst getClientWithEnvCheck = () => {\n  if (\n    !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n    !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n  ) {\n    throw new Error(\n      'NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!'\n    );\n  }\n  return createClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      autoRefreshToken: false,\n      persistSession: false,\n      headers: {\n        'X-Client-Info': `${PKG_NAME.replace('@', '').replace(\n          '/',\n          '-'\n        )}/${PKG_VERSION}`\n      }\n    }\n  );\n};\n\nexport const supabaseClient = getClientWithEnvCheck();\n","import { NextResponse } from 'next/server';\nimport { NextMiddleware } from 'next/server';\nimport {\n  CookieOptions,\n  setCookies,\n  COOKIE_OPTIONS,\n  TOKEN_REFRESH_MARGIN,\n  NextRequestMiddlewareAdapter,\n  NextResponseMiddlewareAdapter,\n  jwtDecoder,\n  User\n} from '@supabase/auth-helpers-shared';\n\nclass NoPermissionError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name() {\n    return this.constructor.name;\n  }\n}\n\nexport interface withMiddlewareAuthOptions {\n  /**\n   * Path relative to the site root to redirect an\n   * unauthenticated visitor.\n   *\n   * The original request route will be appended via\n   * a `redirectedFrom` query parameter, ex: `?redirectedFrom=%2Fdashboard`\n   */\n  redirectTo?: string;\n  cookieOptions?: CookieOptions;\n  tokenRefreshMargin?: number;\n  authGuard?: {\n    isPermitted: (user: User) => Promise<boolean>;\n    redirectTo: string;\n  };\n}\nexport type withMiddlewareAuth = (\n  options?: withMiddlewareAuthOptions\n) => NextMiddleware;\n\nexport const withMiddlewareAuth: withMiddlewareAuth =\n  (options: withMiddlewareAuthOptions = {}) =>\n  async (req) => {\n    try {\n      if (\n        !process.env.NEXT_PUBLIC_SUPABASE_URL ||\n        !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n      ) {\n        throw new Error(\n          'NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!'\n        );\n      }\n      if (!req.cookies) {\n        throw new Error('Not able to parse cookies!');\n      }\n      const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n      const tokenRefreshMargin =\n        options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n      const access_token = req.cookies.get(\n        `${cookieOptions.name!}-access-token`\n      );\n      const refresh_token = req.cookies.get(\n        `${cookieOptions.name!}-refresh-token`\n      );\n\n      const res = NextResponse.next();\n\n      const getUser = async (): Promise<{\n        user: any;\n        error: any;\n      }> => {\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n        // Get payload from access token.\n        const jwtUser = jwtDecoder(access_token);\n        if (!jwtUser?.exp) {\n          throw new Error('Not able to parse JWT payload!');\n        }\n        const timeNow = Math.round(Date.now() / 1000);\n        if (jwtUser.exp < timeNow + tokenRefreshMargin) {\n          if (!refresh_token) {\n            throw new Error('No refresh_token cookie found!');\n          }\n          const requestHeaders: HeadersInit = new Headers();\n          requestHeaders.set('accept', 'json');\n          requestHeaders.set(\n            'apiKey',\n            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n          );\n          requestHeaders.set(\n            'authorization',\n            `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`\n          );\n\n          const data = await fetch(\n            `${process.env.NEXT_PUBLIC_SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`,\n            {\n              method: 'POST',\n              headers: requestHeaders,\n              body: JSON.stringify({ refresh_token })\n            }\n          )\n            .then((res) => res.json())\n            .catch((e) => ({\n              error: String(e)\n            }));\n          setCookies(\n            new NextRequestMiddlewareAdapter(req),\n            new NextResponseMiddlewareAdapter(res),\n            [\n              { key: 'access-token', value: data!.access_token },\n              { key: 'refresh-token', value: data!.refresh_token! }\n            ].map((token) => ({\n              name: `${cookieOptions.name}-${token.key}`,\n              value: token.value,\n              domain: cookieOptions.domain,\n              maxAge: cookieOptions.lifetime ?? 0,\n              path: cookieOptions.path,\n              sameSite: cookieOptions.sameSite\n            }))\n          );\n          return { user: data?.user ?? null, error: data?.error };\n        }\n        return { user: jwtUser, error: null };\n      };\n\n      const authResult = await getUser();\n\n      if (authResult.error) {\n        throw new Error(\n          `Authorization error, redirecting to login page: ${authResult.error.message}`\n        );\n      } else if (!authResult.user) {\n        throw new Error('No auth user, redirecting');\n      } else if (\n        options.authGuard &&\n        !(await options.authGuard.isPermitted(authResult.user))\n      ) {\n        throw new NoPermissionError('User is not permitted, redirecting');\n      }\n\n      // Authentication successful, forward request to protected route\n      return res;\n    } catch (err: unknown) {\n      let { redirectTo = '/' } = options;\n      if (\n        err instanceof NoPermissionError &&\n        !!options?.authGuard?.redirectTo\n      ) {\n        redirectTo = options.authGuard.redirectTo;\n      }\n      if (err instanceof Error) {\n        console.log(\n          `Could not authenticate request, redirecting to ${redirectTo}:`,\n          err\n        );\n      }\n      const redirectUrl = req.nextUrl.clone();\n      redirectUrl.pathname = redirectTo;\n      redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname);\n      // Authentication failed, redirect request\n      return NextResponse.redirect(redirectUrl);\n    }\n  };\n","import {\n  COOKIE_OPTIONS,\n  ProviderTokenNotFound,\n  type CookieOptions\n} from '@supabase/auth-helpers-shared';\nimport {\n  GetServerSidePropsContext,\n  NextApiRequest,\n  NextApiResponse\n} from 'next';\n\ninterface GetProviderTokenOptions {\n  cookieOptions?: CookieOptions;\n}\n\n/**\n * Retrieve provider token from cookies\n * @param context\n * @param { GetProviderTokenOptions } options\n * @returns {string}\n */\nexport function getProviderToken(\n  context:\n    | GetServerSidePropsContext\n    | { req: NextApiRequest; res: NextApiResponse },\n  options: GetProviderTokenOptions = {}\n) {\n  const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n  const providerToken =\n    context.req.cookies[`${cookieOptions.name}-provider-token`];\n\n  if (!providerToken) {\n    throw new ProviderTokenNotFound();\n  }\n\n  return providerToken;\n}\n","import { GetServerSideProps, GetServerSidePropsContext } from 'next';\nimport {\n  AccessTokenNotFound,\n  AuthHelperError,\n  CookieNotParsed,\n  CookieOptions,\n  COOKIE_OPTIONS,\n  jwtDecoder,\n  JWTPayloadFailed,\n  TOKEN_REFRESH_MARGIN\n} from '@supabase/auth-helpers-shared';\nimport getUser from './getUser';\nimport logger from './log';\n\n/**\n * ## Protecting Pages with Server Side Rendering (SSR)\n * If you wrap your `getServerSideProps` with {@link withPageAuth} your props object will be augmented with\n * the user object {@link User}\n *\n * ```js\n * // pages/profile.js\n * import { withPageAuth } from '@supabase/auth-helpers-nextjs';\n *\n * export default function Profile({ user }) {\n *   return <div>Hello {user.name}</div>;\n * }\n *\n * export const getServerSideProps = withPageAuth({ redirectTo: '/login' });\n * ```\n *\n * If there is no authenticated user, they will be redirect to your home page, unless you specify the `redirectTo` option.\n *\n * You can pass in your own `getServerSideProps` method, the props returned from this will be merged with the\n * user props. You can also access the user session data by calling `getUser` inside of this method, eg:\n *\n * ```js\n * // pages/protected-page.js\n * import { withPageAuth, getUser } from '@supabase/auth-helpers-nextjs';\n *\n * export default function ProtectedPage({ user, customProp }) {\n *   return <div>Protected content</div>;\n * }\n *\n * export const getServerSideProps = withPageAuth({\n *   redirectTo: '/foo',\n *   async getServerSideProps(ctx) {\n *     // Run queries with RLS on the server\n *     const { data } = await supabaseServerClient(ctx).from('test').select('*');\n *     return { props: { data } };\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport default function withPageAuth({\n  authRequired = true,\n  redirectTo = '/',\n  getServerSideProps = undefined,\n  cookieOptions = {},\n  tokenRefreshMargin = TOKEN_REFRESH_MARGIN\n}: {\n  authRequired?: boolean;\n  redirectTo?: string;\n  getServerSideProps?: GetServerSideProps;\n  cookieOptions?: CookieOptions;\n  tokenRefreshMargin?: number;\n} = {}) {\n  return async (context: GetServerSidePropsContext) => {\n    try {\n      if (!context.req.cookies) {\n        throw new CookieNotParsed();\n      }\n      cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions };\n      const access_token =\n        context.req.cookies[`${cookieOptions.name}-access-token`];\n      if (!access_token) {\n        throw new AccessTokenNotFound();\n      }\n\n      let user, accessToken;\n      // Get payload from cached access token.\n      const jwtUser = jwtDecoder(access_token);\n      if (!jwtUser?.exp) {\n        throw new JWTPayloadFailed();\n      }\n      const timeNow = Math.round(Date.now() / 1000);\n      if (jwtUser.exp < timeNow + tokenRefreshMargin) {\n        // JWT is expired, let's refresh from Gotrue\n        const response = await getUser(context, { cookieOptions });\n        user = response.user;\n        accessToken = response.accessToken;\n      } else {\n        // Transform JWT and add note that it ise cached from JWT.\n        user = {\n          id: jwtUser.sub,\n          aud: null,\n          role: null,\n          email: null,\n          email_confirmed_at: null,\n          phone: null,\n          confirmed_at: null,\n          last_sign_in_at: null,\n          app_metadata: {},\n          user_metadata: {},\n          identities: [],\n          created_at: null,\n          updated_at: null,\n          'supabase-auth-helpers-note':\n            'This user payload is retrieved from the cached JWT and might be stale. If you need up to date user data, please call the `getUser` method in a server-side context!'\n        };\n        const mergedUser = { ...user, ...jwtUser };\n        user = mergedUser;\n        accessToken = access_token;\n      }\n\n      if (!user) {\n        throw new Error('No user found!');\n      }\n\n      let ret: any = { props: {} };\n      if (getServerSideProps) {\n        try {\n          ret = await getServerSideProps(context);\n        } catch (error) {\n          ret = {\n            props: {\n              error: String(error)\n            }\n          };\n        }\n      }\n      return {\n        ...ret,\n        props: { ...ret.props, user: user, accessToken: accessToken }\n      };\n    } catch (e) {\n      if (authRequired) {\n        return {\n          redirect: {\n            destination: redirectTo,\n            permanent: false\n          }\n        };\n      }\n\n      let props = { user: null, accessToken: null, error: '' };\n      if (e instanceof AuthHelperError) {\n        logger.debug(e.toObj());\n      } else {\n        logger.debug(String(e));\n        props.error = String(e);\n      }\n\n      return {\n        props\n      };\n    }\n  };\n}\n","import { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';\nimport { CookieOptions, COOKIE_OPTIONS, TOKEN_REFRESH_MARGIN } from '@supabase/auth-helpers-shared';\nimport getAccessToken from './getAccessToken';\n\n/**\n * ## Protecting API routes\n * Wrap an API Route to check that the user has a valid session. If they're not logged in the handler will return a\n * 401 Unauthorized.\n *\n * ```js\n * // pages/api/protected-route.js\n * import { withApiAuth, supabaseServerClient } from '@supabase/auth-helpers-nextjs';\n *\n * export default withApiAuth(async function ProtectedRoute(req, res) {\n *   // Run queries with RLS on the server\n *   const { data } = await supabaseServerClient({ req, res }).from('test').select('*');\n *   res.json(data)\n * });\n * ```\n *\n * If you visit `/api/protected-route` without a valid session cookie, you will get a 401 response.\n *\n * @category Server\n */\nexport default function withApiAuth(\n  handler: NextApiHandler,\n  options: { cookieOptions?: CookieOptions; tokenRefreshMargin?: number } = {}\n) {\n  return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {\n    try {\n      const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n      const tokenRefreshMargin =\n        options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n      const accessToken = await getAccessToken(\n        { req, res },\n        { cookieOptions, tokenRefreshMargin }\n      );\n      if (!accessToken) throw new Error('No access token!');\n      try {\n        await handler(req, res);\n      } catch (error) {\n        res.status(500).json({\n          error: String(error)\n        });\n        return;\n      }\n    } catch (error) {\n      res.status(401).json({\n        error: 'not_authenticated',\n        description:\n          'The user does not have an active session or is not authenticated'\n      });\n      return;\n    }\n  };\n}\n","import {\n  GetServerSidePropsContext,\n  NextApiRequest,\n  NextApiResponse\n} from 'next';\nimport getUser from './getUser';\nimport {\n  AccessTokenNotFound,\n  CookieNotParsed,\n  CookieOptions,\n  COOKIE_OPTIONS,\n  jwtDecoder,\n  JWTPayloadFailed,\n  TOKEN_REFRESH_MARGIN\n} from '@supabase/auth-helpers-shared';\n\nexport interface GetAccessTokenOptions {\n  cookieOptions?: CookieOptions;\n  tokenRefreshMargin?: number;\n}\n\nexport default async function getAccessToken(\n  context:\n    | GetServerSidePropsContext\n    | { req: NextApiRequest; res: NextApiResponse },\n  options: GetAccessTokenOptions = {}\n): Promise<string | null> {\n  if (!context.req.cookies) {\n    throw new CookieNotParsed();\n  }\n  const cookieOptions = { ...COOKIE_OPTIONS, ...options.cookieOptions };\n  const tokenRefreshMargin = options.tokenRefreshMargin ?? TOKEN_REFRESH_MARGIN;\n  const access_token =\n    context.req.cookies[`${cookieOptions.name}-access-token`];\n\n  if (!access_token) {\n    throw new AccessTokenNotFound();\n  }\n\n  // Get payload from access token.\n  const jwtUser = jwtDecoder(access_token);\n  if (!jwtUser?.exp) {\n    throw new JWTPayloadFailed();\n  }\n  const timeNow = Math.round(Date.now() / 1000);\n  if (jwtUser.exp < timeNow + tokenRefreshMargin) {\n    // JWT is expired, let's refresh from Gotrue\n    const { accessToken } = await getUser(context, {\n      cookieOptions,\n      tokenRefreshMargin\n    });\n    return accessToken;\n  } else {\n    return access_token;\n  }\n}\n","import { GetServerSidePropsContext, NextApiRequest } from 'next';\nimport { supabaseClient, SupabaseClient } from './initSupabase';\nimport { CookieOptions } from '@supabase/auth-helpers-shared';\n\n/**\n * This is a helper method to wrap your SupabaseClient to inject a user's access_token to make use of RLS on the server side.\n *\n * ```js\n * import { supabaseServerClient } from '@supabase/auth-helpers-nextjs';\n *\n * export async function getServerSideProps(context) {\n *   // Run queries with RLS on the server\n *   const { data } = await supabaseServerClient(context)\n *     .from('test')\n *     .select('*');\n *   return {\n *     props: { data }, // will be passed to the page component as props\n *   }\n * }\n * ```\n *\n * @param supabaseClient\n * @param context\n * @param cookieOptions\n * @returns supabaseClient\n *\n * @category Server\n */\n\nexport default function supabaseServerClient(\n  context: GetServerSidePropsContext | { req: NextApiRequest },\n  cookieOptions: CookieOptions = {\n    name: 'sb'\n  }\n): SupabaseClient {\n  if (!context.req.cookies) {\n    return supabaseClient;\n  }\n  const access_token =\n    context.req.cookies[`${cookieOptions.name}-access-token`];\n\n  if (access_token) supabaseClient.auth.setAuth(access_token);\n  return supabaseClient;\n}\n"],"mappings":"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","names":[]}